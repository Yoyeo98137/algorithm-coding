## 268. 丢失的数字

### 题意

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

### 难度

⭐

### 示例

**示例一：**

```javascript
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。
2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例二：**

```javascript
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。
2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例三：**

```javascript
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。
8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例四：**

```javascript
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。
1 是丢失的数字，因为它没有出现在 nums 中。
```

### 进阶

你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

### 考察

位运算、数组、哈希表、数学、排序

### 实现

```javascript
思路：
计数

/**
 * 排序
 *
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    /**
        排序之后，就只存在两种情况：
        - nums 中不包括这个 [0, n] 的值，说明这个丢失的数字正好是 n 即 num.length
          如：[0, 3] nums = [0, 1, 2] >>> 3
        - nums 存在这个 [0, n] 的值，那我们去找这个排序后的数组下标，
          如果对不上说明当前下标的值就丢失掉了
          如：[0, 3] nums = [3, 0, 1].sort = [0, 1, 3] >>> 2
     */
    nums.sort((a, b) => a - b)

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== i) return i
    }

    return nums.length;
};

时间复杂度：O(nlogn)。
由于排序的时间复杂度为 O(nlogn)，扫描数组的时间复杂度为 O(n)，
因此总的时间复杂度为 O(nlogn)。

空间复杂度：O(1) 或 O(n)。
空间复杂度取决于使用的排序算法，
根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），
空间复杂度为 O(1) 或 O(n)。

/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    const set = new Set()
    const len = nums.length

    // 第一次遍历，在哈希表中存入响应数值
    for (let i = 0; i < len; i++) {
        set.add(nums[i])
    }

    // 第二次遍历，因为 [0, n] 是开区间，所以遍历到 nums.length + 1
    // 如果当前下标不存在于哈希表中，说明这个就是丢失的数字下标，将其抛出
    for (let i = 0; i <= len; i++) {
        if (!set.has(i)) {
            return i
        }
    }
};

时间复杂度：O(n)。
集合的插入操作的时间复杂度都是 O(1)，一共插入了 n 个数，时间复杂度为 O(n)。
集合的查询操作的时间复杂度同样是 O(1)，最多查询 n+1 次，时间复杂度为 O(n)。
因此总的时间复杂度为 O(n)。

空间复杂度：O(n)。
集合中会存储 n 个数，因此空间复杂度为 O(n)。

```
