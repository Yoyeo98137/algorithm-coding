## 387. 字符串中的第一个唯一字符

### 题意

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

### 难度

⭐

### 示例

**示例 1：**

```javascript
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```

### 考察

队列、哈希表、字符串、计数

### 实现

```javascript

/**
 * 两次遍历 + 计数
 *
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    /**
    
        两次遍历，第一次统计字符对应的出现次数，第二次找出第一个出现 1 次的字符索引

     */

    // 对应 26 个英文字母建立数组，存放对应字符的出现次数
    const counts = new Array(26).fill(0)

    // 给每个字符的出现次数进行计数
    for (let i = 0; i < s.length; i++) {
        // 97 是字母 a 的 Unicode 值
        counts[s[i].charCodeAt() - 97]++
    }

    // 找出第一个 只出现 1 次 的字符，抛出索引
    for (let i = 0; i < s.length; i++) {
        if (counts[s[i].charCodeAt() - 97] === 1) {
            return i
        }
    }

    // 不存在只出现 1 次的字符时，返回 -1
    return -1
};

时间复杂度：O(n)
空间复杂度：O(Σ)


/**
 * 哈希
 *
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    /**

        具体地，对于哈希映射中的每一个键值对，键表示一个字符，
        值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。
        
        当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，
        我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。

        在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，
        即为第一个不重复字符的索引。

        如果哈希映射中的所有值均为 −1，我们就返回 −1。
    
     */

    const position = new Map();
    const n = s.length;

    for (let [i, v] of Array.from(s).entries()) {
        // 如果该字符出现多次
        if (position.has(v)) {
            position.set(v, -1);
        }
        // 如果该字符只出现一次，记录下标
        else {
            position.set(v, i);
        }
    }

    let first = n;
    for (let pos of position.values()) {
        // 找出其中不为 −1 的最小值
        if (pos !== -1 && pos < first) {
            first = pos;
        }
    }

    // 如果相等，说明哈希映射中的所有值均为 −1
    if (first === n) {
        first = -1;
    }

    return first;
};

时间复杂度：O(n)，其中 nn 是字符串 s 的长度。我们需要进行两次遍历。
空间复杂度：O(Σ)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 Σ≤26。
我们需要 O(Σ) 的空间存储哈希映射。



/**
 * 队列
 *
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    /**

        我们使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。
        
        当我们对字符串进行遍历时，设当前遍历到的字符为 c，
        如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，
        否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，
        即我们不断地根据哈希映射中存储的值（是否为 −1）选择 弹出队首 的元素，
        直到队首元素「真的」只出现了一次或者队列为空。

        在遍历完成后，如果队列为空，说明没有不重复的字符，返回 −1，
        否则队首的元素即为第一个不重复的字符以及其索引的二元组。

        在维护队列时，我们使用了「延迟删除」这一技巧。

        也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，
        那么就不会对答案造成影响，我们也就可以不用去删除它。
        只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。

     */
    
    const position = new Map();
    const q = [];
    const n = s.length;

    for (let [i, ch] of Array.from(s).entries()) {
        if (!position.has(ch)) {
            // 不存在哈希的时候，通过哈希记录下标
            position.set(ch, i);
            // 并推入一个 二维数组 到队列中
            q.push([ch, i]);

            // q = l e
        } else {
            // 遇到重复记录的哈希值，标记 -1
            position.set(ch, -1);
            // 借助 队列 先进先出 的规则
            // 队列 q 中存的是当前所有的 不重复字符 的值键对
            // 我们要找到第一个不重复字符即 队列的队首
            // 为了防止 队首 记录的是重复字符的情况（即第一个字符属于重复字符）
            // 于是通过 遍历队列 以及 查找队首是否在哈希表中被标记为重复字符
            // 如果是，就移除这个队首即删除开头
            while (q.length && position.get(q[0][0]) === -1) {
                q.shift();
            }
        }
    }

    // 如果队列为空即不存在 不重复的字符，则返回 -1
    return q.length ? q[0][1] : -1;
};

时间复杂度：O(n)
空间复杂度：O(Σ)


```

> 队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。