## 53. 最大子序和

### 题意

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 

### 难度

⭐⭐⭐

### 示例

**示例 1：**

```javascript
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```javascript
输入：nums = [1]
输出：1
```

**示例 3：**

```javascript
输入：nums = [0]
输出：0
```

### 考察

数组、分治、动态规划

### 实现

```javascript

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    /**

        动态规划 DP

        我们使用动态规划求解问题时，需要遵循以下几个重要步骤：
        - 定义子问题
        - 实现需要反复执行解决的子子问题部分
        - 识别并求解出边界条件

        第一步：定义子问题
            动态规划是将整个数组归纳考虑，假设我们已经知道了以第 i-1 个数结尾的连续子数组的最大和为 dp[i-1]，
            显然以第 i 个数结尾的连续子数组的最大和的可能取值要么为：
                dp[i-1] + nums[i]
            要么就是
                nums[i] 单独成一组，也就是 nums[i] 
            所以在这两个数中我们取最大值。

        第二步：实现需要反复执行解决的子子问题部分
            dp[n] = Math.max(dp[n−1] + nums[n], nums[n])

        第三步：识别并求解出边界条件
            dp[0] = nums[0]

        最后一步：把尾码翻译成代码，处理一些边界情况
            因为我们在计算 dp[i] 的时候，只关心 dp[i-1] 与 nums[i]，
            因此不用把整个 dp 数组保存下来，只需设置一个 pre 保存 dp[i-1] 就好了。

        我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，
        再遍历出以 b 为开头的... ...
        但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的。

        所以在思考的时候，可以想象成 以当前点为结束点

     */
    
    // 默认第一个值为最大子序和
    let ans = nums[0];
    // 由于第一个值可能是负数，这里定一个最小正数 0
    let sum = 0;

    for (let num of nums) {
        // if (sum > 0) 可以写成这样
        // 前一个位置为结束点时的最大子序列和 加上 当前值
        // 如果大于当前值，说明 之前的子序列和 加上当前值 还能更大，即组成更大的 连续子序和
        if (sum + num > num ){
            sum = sum + num;
        } else {
            // 否则，当前值比之前的子序和都要大，则将之前的最大子序列更改赋值为当前值
            sum = num;
        }
        // sum 是从 0 开始计算
        // ans 是从 第一个值 开始计算
        ans = Math.max(ans, sum);
    };

    return ans;

    // #################### 2 ####################
    
    if (!nums.length) return;
    
    /**
       状态转移方程：sum[i] = max{ sum[i-1] + a[i], a[i] }
       
        pre 即 sum[i-1]
        maxAns 即 sum[i]

        所以初始值设置的是，前节点的连续和为 0，则
        maxAns = pre + a[i] = 0 + nums[0] = nums[0]
     */
    let pre = 0,
        maxAns = nums[0];

    // 每个值跟前一个值进行比较，所以从下标 1 开始遍历
    for (let i = 1; i < nums.length; i++) {
        // 以每个位置为终点的最大子数列 都是基于其前一位置的最大子数列计算得出,

        pre = Math.max( pre + nums[i], nums[i] );
        maxAns = Math.max( pre, maxAns );
    };

    return maxAns;

    时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。
    空间复杂度：O(1)。我们只需要常数空间存放若干变量。
};

```

> 动态规划
> 解答这类题目, 省略不掉遍历, 因此我们先从遍历方式说起
> 通常我们遍历子串或者子序列有三种遍历方式：
> 
> - 以某个节点为开头的所有子序列如：[a], [a, b], [a, b, c]
> - 根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等
> - 以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，
> 因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如： [a, b, c], [b, c], > c]
>
> 第三种遍历方式因为可以产生递推关系，采用动态规划时，经常通过此种遍历方式
> 这里的动态规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路
> 该算法用到了 “最佳子结构” ↓
>
> 以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出

## 进阶

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

TODO