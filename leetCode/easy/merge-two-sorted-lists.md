## 21. 合并两个有序链表

### 题意

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

### 难度

⭐⭐

### 示例

**示例 1：**

```javascript
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```javascript
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```javascript
输入：l1 = [], l2 = [0]
输出：[0]
```

### 提示

- 两个链表的节点数目范围是 [0, 50]
- -100 <= Node.val <= 100
- l1 和 l2 均按 非递减顺序 排列

### 考察

递归、链表

### 实现

```javascript

/**
 * 递归
 *
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    /**
        理解一：

        我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

        if l1[0] < l2[0]    merge => l1[0], merge(li[1:], l2)
        else                merge => l2[0], merge(li, l2[1:])

        也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。
        
        我们直接将以上递归过程建模，同时需要考虑边界情况。
        如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。
        否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。
        如果两个链表有一个为空，递归结束。

        #############################################################################

        理解二：

        根据题意，我们知道我们的任务是要将两个升序链表合并为一个升序的新链表！

        这就好比，军训的时候，有两个小组，每一组都是按照身高，从左往右依次站立的。
        这时候，教官让我们两个小组，合并为一个小组，并且也要按照身高来站立。
        跟着你的感觉，我们来想象一下如何正确的合并成一个小组，流程如下：

        首先，我们给小组命名，一组为 A，一组为 B，新组合的的 C 组。
        对比 A 组和 B 组现在站在最前面的人的身高，矮的先出来，站在 C 组第一位。
        然后再次对比两组开头的人的身高，矮的又站出来，站在 C 组第二位。
        就这样周而复始，最终，AB 两组的人，全部站到了 C 组，我们的任务也就完成了。

        而我们实现该逻辑的方法，就是：递归！

        这个 C 组，怎么定义呢？
        其实递归就是程序内部维护了一个栈，递归的这个栈就是这里所说的 C 组

     */
    

    if (l1 === null) return l2
    if (l2 === null) return l1

    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    } else {
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
    }
};

时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。
因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），
函数 mergeTwoList 至多只会递归调用每个节点一次。
因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。

空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。
递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。
结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。


/**
 * 迭代
 *
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    /**
    
        迭代

        思路
        我们可以用迭代的方法来实现上述算法。
        当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，
        然后将较小值的节点添加到结果里，
        当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

        算法
        首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。
        我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。
        然后，我们重复以下过程，直到 l1 或者 l2 指向了 null

        如果 l1 当前节点的值小于等于 l2 ，
        我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。
        否则，我们对 l2 做同样的操作。
        不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

        在循环终止的时候， l1 和 l2 至多有一个是非空的。
        由于输入的两个链表都是有序的，所以不管哪个链表是非空的，
        它包含的所有元素都比前面已经合并链表中的所有元素都要大。
        
        这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

     */

    if (l1 === null) return l2
    if (l2 === null) return l1
    
    // 因为 val===undefined ? 0 : val，所以这里给一个具体的值 -1
    const prehead = new ListNode(-1)

    let prev = prehead
    while (l1 !== null && l2 !== null) {
        if (l1.val < l2.val) {
            prev.next = l1
            l1 = l1.next

        } else {
            prev.next = l2
            l2 = l2.next
        }

        // 要记得每次都要把我们的 哨兵 往后移动一位
        prev = prev.next
    }

    // 合并后 l1 和 l2 最多只有一个还没被合并完，直接拼接给 哨兵节点 的末尾即可
    prev.next = l1 === null ? l2 : l1
    
    // 记住这里 哨兵节点 的头结点是一开始设置的 -1
    // 真正拼接的节点从 -1.next 开始
    return prehead.next
};

时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。
因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 
因此 while 循环的次数不会超过两个链表的长度之和。
所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 -O(n+m)。

空间复杂度：O(1)。我们只需要常数的空间存放若干变量。

```

---

对于链表的理解：
每个节点由 val 存储值，由 next 作为指针指向下一个节点（这里是存储节点的地址而不是值）
这是一个链式结构，所以没有什么下标的说法

题目中输入的链表 l1: [1,2,4]
不要当成数组，其实是这样一个 对象 的结构：

    val: 1
    next: 
        val: 2
        next:
            val: 4
            next: null

所以说在进行比较的时候，是直接用的 .val 进行比较
理解链表的结构就不饶了，链表的每个节点都是由 值（val）与 指针（next）组成的
然后通过指针指向另一个节点的 地址