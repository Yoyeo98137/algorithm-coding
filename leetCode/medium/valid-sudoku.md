## 36. 有效的数独

### 题意

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 '.' 表示。

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。

### 难度

⭐⭐⭐⭐

### 示例

**示例 1：**

```javascript
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```javascript
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

### 考察

数组、哈希、矩阵

### 实现

```javascript

/**
 * 数学公式 + 哈希表
 *
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
    const rowMap = new Map()
    const colMap = new Map()
    const boxesMap = new Map()

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            const items = board[i][j]
            /**
                定义 3 个长度为 9 的哈希表：
                第一个：九行 rowMap
                第二个：九列 colMap
                第三个：九个 3*3 组成的子数独 boxesMap

                通过遍历填充值
                1 遍历整个数独
                2 rowMap[i] 存放对应 当前行 存在的值。
                3 colMap[j] 存放对应 当前列 存在的值。
                4 boxesMap[?] 存放对应 当前子数独 存在的值。

                现在来确定这个 ? ，我们假设仅存在一个 3*9（三行九列）的时候
                对于列数 j:       j = 0/1/2     j = 3/4/5     j = 6/7/8
                对于的子数独为：  boxesMap[0]   boxesMap[1]   boxesMap[2]

                由此得出 boxesMap[j] = Math.floor(j / 3)

                此时结合规律构建出 9*9 数独
                对于行数 i：
                0/1/2  boxesMap[0] boxesMap[1] boxesMap[2]
                3/4/5  boxesMap[3] boxesMap[4] boxesMap[5]
                6/7/8  boxesMap[6] boxesMap[7] boxesMap[8]

                由此得出 boxesMap[i] = Math.floor(i / 3) * 3
                这样理解: 满3换行 ---> Math.floor(i / 3) 一行包含三个子数独 ---> * 3
             */
            const boxIndex = Math.floor(j / 3) + Math.floor(i / 3) * 3

            if (items !== '.') {
                if (
                    rowMap.get(`${ i }-${ items }`) ||
                    colMap.get(`${ j }-${ items }`) ||
                    boxesMap.get(`${ boxIndex }-${ items }`)
                ) {
                    return false
                }
            }
            
            // 记录同一行出现过的数字
            rowMap.set(`${ i }-${ items }`, true)
            // 记录同一列出现过的数字
            colMap.set(`${ j }-${ items }`, true)
            boxesMap.set(`${ boxIndex }-${ items }`, true)
        }
    }

    return true
};

时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。
空间复杂度：O(1)。

为什么都是 常数级 的复杂度，因为这里只用了题目中固定的 81 长度即不存在根据入参进行变化的渐进复杂度

在查询方面，数组要比哈希更有优势

```
