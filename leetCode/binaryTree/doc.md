## 二叉树

**名词**

- 根节点
- 左子树
- 右子树
- 叶子节点：没有子节点的节点
- 树的高度  
  对于任意节点 n，n 的高度为从 n 到任意一个叶子节点的最长路径长，所有树叶的高度为 0
- 树的深度  
  对于任意节点 n，n 的深度为从根到 n 的唯一路径长，根的深度为 0
- 最近公共祖先  
  即对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x  
  满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）


*++关于 树的深度和高度 stackoverflow 上的回答++*  

![image](https://pica.zhimg.com/80/v2-0e8c24776a03380a4db561d47f68847c_720w.jpg?source=1940ef5c)


- 对称二叉树
  - 根节点相同
  - 一颗树的右子树，和另颗个树的左子树镜像对称
- 二叉搜索树  
  即根节点的值一定大于左节点，同时也小于右节点
- 二叉树的层序遍历  
  即逐层地，从左到右访问所有节点（BFS）
- 高度平衡  
  即满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树  
  绝对值函数：Math.abs()

**涉及算法**

- DFS 深度优先搜索 递归
- BFS 广度优先搜索 迭代

**递归三部曲**

- 确定递归函数返回值及其参数
- 确定递归终止条件
- 确定单层递归的逻辑


通常情况下使用

```javascript
if (root === null) return
```

来结束递归，这表示递归查找节点的时候，越过了叶子节点，  
也就是在当前路径上不会再找到更多的节点了

递归的时候怎么代表遍历子树呢？很简单，将左右节点分别作为下一次递归的根节点

```javascript
const left = deep(root.left)
const right = deep(root.right)
```

这会以当前二叉树根节点的左右节点分别打开一条搜索路径，  
从左右节点一直开始向下查找各自的子树（递），  
然后再根据路径把处理的内容带回给根节点（归）。

而在使用 **迭代算法** 处理二叉树的题目时，  
引入一个队列来模拟递归中的「隐式栈」，是把递归程序改写成迭代程序的常用方法。
