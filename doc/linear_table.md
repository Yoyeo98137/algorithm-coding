## 线性表与非线性表
线性表（Linear List）：就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是线性表结构。    
![image](https://camo.githubusercontent.com/574771db72ab154edbe2d44e688df15ca5855a2a8028d7af39ae23fab67e7bc0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d636665393938626365303866616534332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。  
![image](https://camo.githubusercontent.com/76c20596ab327f19827b8f9268ec8bf37a3247773cc899e7deaa5fde18f3ec11/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d396164376138393434323430313036622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

> 先总结 线性表

### 数组
- 数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问
- 数组的索引是从 0 开始的

数组是用一组连续的内存空间来存储的。  
所以数组支持 随机访问，**根据下标随机访问的时间复杂度为 O(1)**。  
但是数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，  
因为底层通常是要进行大量的数据搬移来保持数据的连续性。  

**插入与删除的时间复杂度如下：**  
插入：从最好 O(1) ，最坏 O(n) ，平均 O(n)  
删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)

> JavaScript 原生支持数组，本身也提供了很多操作方法

### 栈
- 后进者先出，先进者后出，简称 **后进先出（LIFO）**，这就是典型的 **栈结构**
- 新添加的或待删除的元素都保存在栈的末尾，称作**栈顶**，另一端就叫**栈底**
- 在栈里，新元素都靠近栈顶，旧元素都接近栈底
- 从栈的操作特性来看，*是一种 操作受限的线性表，只允许在一端插入和删除数据*
- 不包含任何元素的栈称为 空栈

### 队列
#### 普通队列
- 队列是遵循 FIFO（First In First Out，**先进先出**）原则的一组有序的项
- 队列在尾部添加新元素，并从顶部移除元素
- 最新添加的元素必须排在队列的末尾
- 队列只有 入队 push() 和出队 pop()

#### 优先队列
优先队列中元素的添加和移除是 依赖优先级 的。

- 一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。
- 再比如：火车，老年人、孕妇和带小孩的乘客是享有优先检票权的。

优先队列分为两类：最小优先队列、最大优先队列  

最小优先队列 是把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。  
比如：有四个元素："John", "Jack", "Camila", "Tom"，他们的优先级值分别为 4，3，2，1。  
那么最小优先队列排序应该为："Tom"，"Camila"，"Jack"，"John"。
  
最大优先队列 正好相反，把优先级值最大的元素放置在队列的最前面。  
以上面的为例，最大优先队列排序应该为："John", "Jack", "Camila", "Tom"。

#### 循环队列
循环队列，顾名思义，它长得像一个环。把它想像成一个圆的钟就对了。  
关键是：确定好队空和队满的判定条件。

### 链表
- 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，  
  它是通过 **指针** 将 **零散的内存块** 串连起来的。
- 每个元素由一个存储元素本身的 节点 和一个指向下一个元素的 **引用（也称指针或链接）** 组成。

![image](https://camo.githubusercontent.com/626d555992d9ca825cb616a08a0401b6808554b29f60d74a0c390bbd354c7347/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d613463623739336139323736643335382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

其中，data 中保存着数据，next 保存着下一个链表的引用。  
上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。  
值得注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。

- 链表是通过指针将零散的内存块串连起来的。  
  所以链表不支持 随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。  
  所以访问的时间复杂度为 O(n)。
- 高效的插入和删除。
  链表中插入或者删除一个数据，   
  我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，  
  只需要考虑相邻结点的指针改变。   
  所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。

三种最常见的链表结构，它们分别是：

- 单链表
- 双向链表
- 循环链表

#### 单链表
在 JavaScript 中，单链表的真实数据有点类似于对象

#### 双向链表
单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。  
而双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，  
还有一个前驱指针 prev 指向前面的结点。

> 链表代码实现的关键是弄清楚：前节点与后节点与边界

#### 循环链表
循环链表是一种特殊的单链表。  
循环链表和单链表相似，节点类型都是一样。  
唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性指向它本身。
即：

    head.next = head; （单链表最终指的是 null，循环链表最终指回头部从而导致循环）
    
这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，  
换句话说，也就是链表的尾节点指向了头节点，形成了一个循环链表。

循环链表：在单链表的基础上，将尾节点的指针指向头结点，就构成了一个循环链表。  
环形链表从任意一个节点开始，都可以遍历整个链表。

**链表总结**

- 写链表代码是最考验逻辑思维能力的，要熟练链表，只有 多写多练，没有捷径。
- 因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。
- 链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。
- 所以，这也是很多面试官喜欢让人手写链表代码的原因。
- 一定要自己写代码实现一下，才有效果。

> TODO...


