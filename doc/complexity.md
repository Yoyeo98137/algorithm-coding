# 时间和空间复杂度

> 如何让计算机更快时间、更省空间的解决问题  
复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系

## 如何进行复杂度分析？

### 大 O 表示法  
算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示，  
其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模。  
这就是大 O 时间复杂度表示法。

### 时间复杂度
算法的时间复杂度，也就是算法的时间量度。  
大 O 时间复杂度表示法 实际上并不具体表示代码真正的执行时间，  
而是表示 代码执行时间随数据规模增长的变化趋势，所以也叫 渐进时间复杂度，  
简称 **时间复杂度（asymptotic time complexity）**。

🌰  这个方法需要执行 2 次运算
```
function aFun() {
    console.log("Hello, World!");  // 需要执行 1 次
    return 0;  // 需要执行 1 次
}
```

🌰  那么这个方法需要执行 n + 1 + n + 1 = 2n + 2 次运算
```
function bFun(n) {
    for(let i = 0; i < n; i++) {  // 需要执行 (n + 1) 次
        console.log("Hello, World!");  // 需要执行 n 次
    }
    return 0;  // 需要执行 1 次
}
```

🌰  那么这个方法需要执行 
```math
( n2 + n2 + n + n + 1 + 1 +1 ) = 2n^2 + 2n + 3
```
```
function cal(n) {
    let sum = 0;  // 1 次
    let i = 1;  // 1 次
    let j = 1;  // 1 次
    for (; i <= n; ++i) {  // n 次
        j = 1;  // n 次
        for (; j <= n; ++j) {  // n * n ，也即是  n平方次
            sum = sum +  i * j;  // n * n ，也即是  n平方次
        }
    }
}
```

以时间复杂度为例，由于 时间复杂度 描述的是算法执行时间与数据规模的 增长变化趋势，  
**所以 常量、低阶、系数 实际上对这种增长趋势不产生决定性影响**，  
所以在做时间复杂度分析时 **忽略** 这些项。

所以，上面例子1 的时间复杂度为 T(n) = O(1)，例子2 的时间复杂度为 T(n) = O(n)，例子3 的时间复杂度为 T(n) = O(n2)。

所以上面例子的时间复杂度分别为：

```math
常数阶：T(n) = O(1)
```
```math
线性阶：T(n) = O(n)
```
```math
平方阶：T(n) = O(n^2)
```

```
// 对数阶
let i = 1;
while (i <= n) {
   i = i * 2;
}
```
从 1 开始，每次循环就乘以 2，当大于 n 时，循环结束  
其实就是高中学过的等比数列，i 的取值就是一个等比数列，在数学里面是这样子的：
```math
2^0 2^1 2^2 ... 2^k ... 2^x = n
```
所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，  
数学中求解得 x = log2n 。所以上面代码的时间复杂度为 O(log2n)。

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。  
为什么呢？因为对数之间是可以互相转换的，log3n = log32 * log2n，  
所以 O(log3n) = O(C * log2n)，其中 C -= log32 是一个常量。

再由于忽略 常数，则上面的时间复杂度为：
```math
对数阶：T(n) = O(logN)
```
<!--log_{a}{b}-->

```
// 线性对数阶
function aFun(n){
  let i = 1;
  while (i <= n)  {
     i = i * 2;
  }
  return i
}

function cal(n) { 
   let sum = 0;
   for (let i = 1; i <= n; ++i) {
     sum = sum + aFun(n);
   }
   return sum;
}
```
aFun 的时间复杂度为 O(logN)，而 cal 的时间复杂度为 O，  
所以上面代码的时间复杂度为 T(n) = T1(logn) * T2(n) = O(logn*n) = O(nlogn) 。

```math
线性对数阶：T(n) = O(nlogN)
```

### 时间复杂度分析

- 只关注循环执行次数最多的一段代码 （忽略常亮、低阶）
- 加法法则：总复杂度等于量级最大的那段代码的复杂度 （单循环及多重循环，取多重循环的复杂度）
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 （如递归、多重循环等）
- 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加 （O(m+n)）
- 多个规模求乘法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘 （O(m*n)）

### 时间复杂度总结

常用的时间复杂度所耗费的时间从小到大依次是：
```math
O(1) < O(logN) < (n) < O(nlogN) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
```

常见的时间复杂度：  
![image](https://camo.githubusercontent.com/0e81ab0549a6c17641177e88fa6cd41a5659f4634f7c2367b83a7301e5ecc49b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d306662626137366638323930353566662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

### 空间复杂度分析

时间复杂度的全称是 渐进时间复杂度，表示 算法的执行时间与数据规模之间的增长关系 。

类比一下，空间复杂度全称就是 渐进空间复杂度（asymptotic space complexity），  
表示 **算法的存储空间与数据规模之间的增长关系**。

定义：算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：  
S(n) = O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。

```
function print(n) {
 const newArr = []; // 第 2 行
 newArr.length = n; // 第 3 行
  for (let i = 0; i <n; ++i) {
    newArr[i] = i * i;
  }

  for (let j = n-1; j >= 0; --j) {
    console.log(newArr[i])
  }
}
```

跟时间复杂度分析一样，在第 2 行代码中，我们申请了一个空间存储变量 newArr ，是个空数组。  
第 3 行把 newArr 的长度 ==修改== 为 n 的长度的数组，每项的值为 undefined ，  
除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

> 我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，  
像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。  
整理参考于：https://github.com/biaochenxuying/blog/issues/29   
**仅个人学习记录**