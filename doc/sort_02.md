### 归并排序、快速排序、希尔排序、堆排序

> 之所以把归并排序、快速排序、希尔排序、堆排序放在一起比较，  
是因为它们的平均时间复杂度都为 O(nlogn)。

#### 归并排序（Merge Sort）

↓思想：

排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，  
再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序采用的是 **分治思想**。

分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。  
小的子问题解决了，大问题也就解决了。

↓分析：

- 第一，归并排序是原地排序算法吗 ？  
    这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。  
    实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。  
    在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。  
    临时内存空间最大也不会超过 n 个数据的大小，所以 **空间复杂度是 O(n)**。  
    所以，归并排序不是原地排序算法。

- 第二，归并排序是稳定的排序算法吗 ？  
    merge 方法里面的 left[0] <= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。  
    归并排序是一种稳定的排序方法。

- 第三，归并排序的时间复杂度是多少 ？  
    从效率上看，归并排序可算是排序算法中的佼佼者。  
    假设数组长度为 n，那么拆分数组共需 logn 步, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合 **时间复杂度为 O(nlogn)**。

最佳情况：T(n) = O(nlogn)。  
最差情况：T(n) = O(nlogn)。  
平均情况：T(n) = O(nlogn)。

#### 快速排序（Quick Sort）

快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。

↓思想：

先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，
如果比它小，放左边；反之，放右边。  
左右分别用一个空数组去存储比较后的数据。  
最后递归执行上述操作，直到数组长度 <= 1;  

特点：快速，常用。  
缺点：需要另外声明两个数组，浪费了内存空间资源。

↓分析：
- 第一，快速排序是原地排序算法吗 ？  
  因为 partition() 函数进行分区时，不需要很多额外的内存空间，所以快排是原地排序算法。

- 第二，快速排序是稳定的排序算法吗 ？  
  和选择排序相似，快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并不稳定。

- 第三，快速排序的时间复杂度是多少 ？  
  极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。  
  如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。  
  我们需要进行大约 n 次分区操作，才能完成快排的整个过程。  
  每次分区我们平均要扫描大约 n / 2 个元素，  
  这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。

最佳情况：T(n) = O(nlogn)。  
最差情况：T(n) = O(n2)。

快排和归并用的都是 **分治思想**，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ？

- 归并排序的处理过程是 **由下而上** 的，先处理子问题，然后再合并。
- 而快排正好相反，它的处理过程是 **由上而下** 的，先分区，然后再处理子问题。
- 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。
- 归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。
- 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

#### 堆排序（Heap Sort）

