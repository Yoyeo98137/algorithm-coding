### 归并排序、快速排序、希尔排序、堆排序

> 之所以把归并排序、快速排序、希尔排序、堆排序放在一起比较，  
是因为它们的平均时间复杂度都为 O(nlogn)。

#### 归并排序（Merge Sort）

↓思想：

排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，  
再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序采用的是 **分治思想**。

分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。  
小的子问题解决了，大问题也就解决了。

↓分析：

- 第一，归并排序是原地排序算法吗 ？  
    这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。  
    实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。  
    在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。  
    临时内存空间最大也不会超过 n 个数据的大小，所以 **空间复杂度是 O(n)**。  
    所以，归并排序不是原地排序算法。

- 第二，归并排序是稳定的排序算法吗 ？  
    merge 方法里面的 left[0] <= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。  
    归并排序是一种稳定的排序方法。

- 第三，归并排序的时间复杂度是多少 ？  
    从效率上看，归并排序可算是排序算法中的佼佼者。  
    假设数组长度为 n，那么拆分数组共需 logn 步, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合 **时间复杂度为 O(nlogn)**。

最佳情况：T(n) = O(nlogn)。  
最差情况：T(n) = O(nlogn)。  
平均情况：T(n) = O(nlogn)。

#### 快速排序（Quick Sort）

快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。

↓思想：

先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，
如果比它小，放左边；反之，放右边。  
左右分别用一个空数组去存储比较后的数据。  
最后递归执行上述操作，直到数组长度 <= 1;  

特点：快速，常用。  
缺点：需要另外声明两个数组，浪费了内存空间资源。


