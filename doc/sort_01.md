### 冒泡排序、插入排序、选择排序

> 它们三者的平均时间复杂度都为 O(n2)

#### 冒泡排序

↓思路：

- 冒泡排序只会操作 *相邻的两个数据*。
- 每次冒泡操作都会对 相邻 的两个元素进行 比较，看 *是否满足大小关系要求*。如果不满足就让它俩 互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

↓特点：

- 优点：排序算法的基础，简单实用易于理解。
- 缺点：比较次数多，效率较低。

#### 插入排序

插入排序又为分为 *直接插入排序* 和优化后的 *拆半插入排序* 与 *希尔排序*，我们通常说的插入排序是指**直接插入排序**。

##### 直接插入

↓思想：

一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，  
那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。

原理：**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**

↓步骤：

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤 2~5。

##### 拆半插入

插入排序也有一种优化算法，叫做拆半插入。

↓思想：

折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组，  
我们不必按顺序依次寻找插入点, 只需比较它们的 *中间值* 与 *待插入元素* 的大小即可。

↓步骤：

- 取 0 ~ i-1 的中间点 ( **m = (i-1)>>1** )，array[i] 与 array[m] 进行比较，  
  若 array[i] < array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；  
  反之，则说明它应该处于数组的 m ~ i-1 索引之间。
- 重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。
- 将数组中插入位置之后的元素全部后移一位。
- 在指定位置插入第 i 个元素。

> 注：x>>1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x>>1 == Math.floor(x/2) 。  
和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。

