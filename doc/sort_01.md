### 冒泡排序、插入排序、选择排序

> 它们三者的平均时间复杂度都为 O(n2)

#### 冒泡排序

↓思路：

- 冒泡排序只会操作 *相邻的两个数据*。
- 每次冒泡操作都会对 相邻 的两个元素进行 比较，看 *是否满足大小关系要求*。如果不满足就让它俩 互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

↓特点：

- 优点：排序算法的基础，简单实用易于理解。
- 缺点：比较次数多，效率较低。

↓分析：

- 第一，冒泡排序是原地排序算法吗 ？  
    冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 
- 第二，冒泡排序是稳定的排序算法吗 ？  
    在冒泡排序中，只有交换才可以改变两个元素的前后顺序。  
    为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。  
    所以冒泡排序是稳定的排序算法。
- 第三，冒泡排序的时间复杂度是多少 ？  
    最佳情况：T(n) = O(n)，当数据已经是正序时。  
    最差情况：T(n) = O(n2)，当数据是反序时。  
    平均情况：T(n) = O(n2)。

#### 插入排序

插入排序又为分为 *直接插入排序* 和优化后的 *拆半插入排序* 与 *希尔排序*，我们通常说的插入排序是指**直接插入排序**。

##### 直接插入

↓思想：

一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，  
那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。

原理：**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**

↓步骤：

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤 2~5。

##### 拆半插入

插入排序也有一种优化算法，叫做拆半插入。

↓思想：

折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组，  
我们不必按顺序依次寻找插入点, 只需比较它们的 *中间值* 与 *待插入元素* 的大小即可。

↓步骤：

- 取 0 ~ i-1 的中间点 ( **m = (i-1)>>1** )，array[i] 与 array[m] 进行比较，  
  若 array[i] < array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；  
  反之，则说明它应该处于数组的 m ~ i-1 索引之间。
- 重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。
- 将数组中插入位置之后的元素全部后移一位。
- 在指定位置插入第 i 个元素。

> 注：x>>1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x>>1 == Math.floor(x/2) 。  
和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。

↓分析：

- 第一，插入排序是原地排序算法吗 ？  
    插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个原地排序算法。
- 第二，插入排序是稳定的排序算法吗 ？  
    在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
- 第三，插入排序的时间复杂度是多少 ？  
    最佳情况：T(n) = O(n)，当数据已经是正序时。  
    最差情况：T(n) = O(n2)，当数据是反序时。  
    平均情况：T(n) = O(n2)。

#### 选择排序

↓思想：

选择排序算法的实现思路有点类似插入排序，也分 *已排序区间* 和 *未排序区间*。  
但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

↓步骤：

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。

↓分析：

- 第一，选择排序是原地排序算法吗 ？
    选择排序空间复杂度为 O(1)，是一种原地排序算法。
- 第二，选择排序是稳定的排序算法吗
    选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种不稳定的排序算法。
- 第三，选择排序的时间复杂度是多少 ？
    无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。

最佳情况：T(n) = O(n2)。  
最差情况：T(n) = O(n2)。  
平均情况：T(n) = O(n2)。